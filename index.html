<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Memleak by ssthappy</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Memleak</h1>
        <p>Dynamically validating static memory leak warnings</p>

        <p class="view"><a href="https://github.com/ssthappy/memleak">View the Project on GitHub <small>ssthappy/memleak</small></a></p>


        <ul>
          <li><a href="https://github.com/ssthappy/memleak/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/ssthappy/memleak/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/ssthappy/memleak">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>This site presents our memory leak validation tool and experiment data.</p>
    <p>SEG (Software Engineering Group) , Nanjing University</p>

<h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>Memory leaks have significant impact on software availability, performance and security. Static analysis has been widely used to find memory leaks in C/C++ programs. Although a static analysis is able to find all potential leaks in a program, it often reports a great number of false warnings. Manually validating these warnings is a daunting task, which significantly limits the practicality of the analysis. So we develop a novel dynamic technique that automatically validates and categorizes such warnings to unleash the power of static memory leak detectors. Our technique analyzes each warning that contains information regarding the leaking allocation site and the leaking path, generates test cases to cover the leaking path, and tracks objects created by the leaking allocation site. Eventually, warnings are classified into four categories: MUST-LEAK, LIKELY-NOT-LEAK, BLOAT, and MAY-LEAK.</p>

<h3>
<a id="warning-classification" class="anchor" href="#warning-classification" aria-hidden="true"><span class="octicon octicon-link"></span></a>Warning classification</h3>

<p>Warnings are classified into four categories: <b>MUST-LEAK</b>, <b>LIKELY-NOT-LEAK</b>, <b>BLOAT</b>, and <b>MAY-LEAK</b>.</p>
<p>Warnings in MUST-LEAK are guaranteed by our analysis to be true leaks. Warnings in LIKELY-NOT-LEAK are highly likely to be false warnings. Although we cannot provide any formal guarantee that they are not leaks, we have high confidence that this is the case. Warnings in BLOAT are also not likely to be leaks but they should be fixed to improve performance. Using our approach, the developer's manual verification effort needs to be focused only on warnings in the category MAY-LEAK, which is often much smaller than the original set.</p>
<h3>
<a id="analysis-algorithm" class="anchor" href="#analysis-algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Analysis algorithm</h3>
<img src="images/fig4.jpg"  border="0" />
<p>Figure above shows an overview of our tool. <br>Given a static leak warning <i>w</i> = (<i>a</i>, <i>p</i>, <i>e</i>), two pre-processing phases are performed prior to the test case generation.  In the first phase, the target program is instrumented. The inserted code serves two major purposes: (1) it declares symbolic variables and marks the path fragment <i>p</i> in the source code for the subsequent path-directed concolic testing; (2) it tracks the usage of each run-time object created by the reported allocation site <i>a</i> and updates its tracking data. The second phase consists of a path reachability analysis, which is performed on the CFG of the program to determine, for each control flow branch, whether an execution following the branch could potentially reach each branch on <i>p</i>. This analysis is straightforward: it combines an intraprocedural control-dependence analysis with an interprocedural call graph traversal. The concolic testing engine is then modified to be aware of this reachability information so that the test case generation is guided to explore only the paths that may reach <i>p</i>, leading to a reduced search space in the symbolic execution.  The
tracking data for each tracked object is inspected at the end of the execution to classify the warning.</p>
<h3>
<a id="experiment" class="anchor" href="#experiment" aria-hidden="true"><span class="octicon octicon-link"></span></a>Experiment</h3>

<p>Our instrumentation was performed using the <a href="http://sourceforge.net/projects/cil/">CIL</a> instrumentation framework. The <a href="https://github.com/jburnim/crest">CREST</a> concolic testing engine was modified to perform the path-guided test case generation. The static memory leak detector used in our experiments was HP Fortify version 3.2.</p>

<h4>
<a id="Experimental Subjects" class="anchor" href="#benchmark" aria-hidden="true"><span class="octicon octicon-link"></span></a>Experimental Subjects</h4>
<p>We perform our first and third experiment using a set of programs from the <a href="http://sir.unl.edu">Siemens</a> and the <a href="http://www.gnu.org/software/coreutils/">coreutils</a> benchmark suites. These programs are relatively small and it is thus easy for us to understand their implementation logic to manually verify our classification results and overhead. To increase the number of static analysis warnings for each program, we manually injected both true and false leaks. The injected benchmark can download <a href="download/benchmark.zip">here</a>, including inject information table.</br>The programs are as follows:</p>
<table>
<tr><td>Program</td>  <td>Lines</td>  <td>Description</td></tr>
<tr><td>replace</td>  <td>563</td>  <td>Replace pattern</td></tr>
<tr><td>print_tokens</td> <td>726</td>  <td>Lexical analysis</td></tr>
<tr><td>print_tokens2</td>  <td>569</td>  <td>Lexical analysis</td></tr>
<tr><td>tcas</td> <td>173</td>  <td>Collision avoidance</td></tr>
<tr><td>wc</td> <td>802</td>  <td>Print newline, word, and byte counts for each file</td></tr>
<tr><td>cat</td>  <td>785</td>  <td>Concatenate and write files</td></tr>
<tr><td>head</td> <td>1063</td> <td>Output the first part of files</td></tr>
<tr><td>tr</td> <td>1949</td> <td>Translate or delete characters</td></tr>
<tr><td>expand</td> <td>433</td>  <td>Convert tabs to spaces</td></tr>
<tr><td>unexpand</td> <td>535</td>  <td>Convert spaces to tabs</td></tr>
</table>
<p>The second experiment includes a case study on the use of our tool to validate leaks for a large-scale application (i.e.,texinfo-4.33).</p>
<h4>
<a id="result" class="anchor" href="#result" aria-hidden="true"><span class="octicon octicon-link"></span></a>Results</h4>
<p>Experiment 1:</p>
Raw data for experiment 1 can download <a href="download/exp1_data.xlsx">here</a>.
<table>
<tr><td>Program</td>  <td>#L</td> <td>#W</td> <td>#S</td> <td>#Must</td>  <td>#LNL</td> <td>#B</td> <td>#May</td> <td>#F</td>  <td>T<sub>0</sub>(s)</td> <td>T<sub>1</sub>(s)</td>  <td>Sp<sub>0</sub>(Mb)</td>  <td>Sp<sub>1</sub>(Mb)</td></tr>
<tr><td>replace</td>  <td>563</td>  <td>18</td> <td>3444</td> <td>5</td>  <td>3</td>  <td>4</td>  <td>6</td>  <td>0</td>  <td>3.82</td> <td>3.95</td> <td>16.4</td> <td>20.4</td></tr>
<tr><td>print_tokens</td> <td>726</td>  <td>22</td> <td>17383</td>  <td>8</td>  <td>4</td>  <td>6</td>  <td>4</td>  <td>0</td>  <td>3.7</td>  <td>5.0</td>  <td>16.9</td> <td>20.6</td></tr>
<tr><td>print_tokens2</td>  <td>569</td>  <td>29</td> <td>16943</td>  <td>8</td>  <td>7</td>  <td>9</td>  <td>5</td>  <td>0</td>  <td>4.2</td>  <td>4.7</td>  <td>22.1</td> <td>22.2</td></tr>
<tr><td>tcas</td> <td>173</td>  <td>8</td>  <td>54</td> <td>1</td>  <td>4</td>  <td>1</td>  <td>2</td>  <td>0</td>  <td>0.06</td> <td>0.07</td> <td>15.6</td> <td>19.8</td></tr>
<tr><td>wc</td> <td>802</td>  <td>8</td>  <td>6000</td> <td>2</td>  <td>2</td>  <td>2</td>  <td>2</td>  <td>0</td>  <td>10.5</td> <td>15.5</td> <td>17.1</td> <td>22.8</td></tr>
<tr><td>cat</td>  <td>785</td>  <td>8</td>  <td>4002</td> <td>2</td>  <td>1</td>  <td>2</td>  <td>3</td>  <td>0</td>  <td>16.9</td> <td>26.2</td> <td>15.7</td> <td>19.9</td></tr>
<tr><td>head</td> <td>1063</td> <td>18</td> <td>5007</td> <td>4</td>  <td>6</td>  <td>2</td>  <td>6</td>  <td>0</td>  <td>12.2</td> <td>17.4</td> <td>16.3</td> <td>20.5</td></tr>
<tr><td>tr</td> <td>1949</td> <td>32</td> <td>37281</td>  <td>11</td> <td>8</td>  <td>8</td>  <td>5</td>  <td>0</td>  <td>21.2</td> <td>26.5</td> <td>16.8</td> <td>21.2</td></tr>
<tr><td>expand</td> <td>433</td>  <td>6</td>  <td>3854</td> <td>1</td>  <td>1</td>  <td>2</td>  <td>2</td>  <td>0</td>  <td>22.3</td> <td>26.9</td> <td>21.8</td> <td>25.9</td></tr>
<tr><td>unexpand</td> <td>535</td>  <td>6</td>  <td>3996</td> <td>1</td>  <td>1</td>  <td>2</td>  <td>2</td>  <td>0</td>  <td>25.7</td> <td>26.2</td> <td>23.1</td> <td>27.2</td></tr>
</table>
<p>#L: Lines of code; </br>#W: Numbers of warnings reported by Fortify; </br>#S: Numbers of test cases generated by the path-guided concolic testing</br>#Must: MUST-LEAK; #LNL: LIKELY-NOT-LEAK; #B: BLOAT; #May: MAY-LEAK; </br>#F: False Classifications;</br>T<sub>0</sub> T<sub>1</sub>:Running times;</br>Sp<sub>0</sub> Sp<sub>1</sub>:Peak memory consumptions.</br></p>


<p>Experiment 2:</p>
<p>Fortify reports a total of 91 warnings for texinfo. Our analysis has successfully classified 70 of them. For the rest 21 of the warnings, no test case can be generated by CREST to exercise their reported path fragments and thus they are classified as MAY-LEAK. This is primarily because the path constraints for these warnings are too complicated to solve. Among the 70 warnings that are precisely classified, the numbers of warnings in MUST-LEAK, LIKELY-NOT-LEAK, and BLOAT are, respectively, 69, 1, and 0.

<p>Experiment 3:</p>
<p>We use <a href="http://valgrind.org/">Valgrind</a> to compare and evaluate our method performance and overhead. The benmark is same with experiment1.</p>
<table>
<tr><td>Program</td>  <td>#L</td> <td>#LP</td> <td>#LP<sub>0</sub></td> <td>#LP<sub>1</sub></td>  <td>#S</td> <td>#TC</td>  <td>T<sub>0</sub>(s)</td> <td>T<sub>1</sub>(s)</td>  <td>Sp<sub>0</sub>(Mb)</td>  <td>Sp<sub>1</sub>(Mb)</td></tr>
<tr><td>replace</td>  <td>563</td>  <td>7</td> <td>5</td> <td>7</td>  <td>3444</td>  <td>5542</td>  <td>30.77</td>  <td>4968.12</td>  <td>549.9/20.4</td> <td>28.9</td></tr>
<tr><td>print_tokens</td> <td>726</td>  <td>4</td> <td>4</td>  <td>4</td>  <td>17383</td>  <td>4130</td>  <td>32.16</td>  <td>3737.74</td>  <td>545/20.6</td>  <td>29.3</td></tr>
<tr><td>print_tokens2</td>  <td>569</td>  <td>2</td> <td>2</td>  <td>2</td>  <td>16943</td>  <td>4115</td>  <td>30</td>  <td>3735.83</td>  <td>551.1/22.2</td>  <td>27.9</td></tr>
<tr><td>tcas</td> <td>173</td>  <td>2</td>  <td>1</td> <td>2</td>  <td>54</td>  <td>1608</td>  <td>24.53</td>  <td>1424.58</td>  <td>552.6/19.8</td> <td>27.9</td></tr>
<tr><td>wc</td> <td>802</td>  <td>1</td>  <td>1</td> <td>1</td>  <td>6000</td>  <td>835</td>  <td>48.44</td>  <td>1807</td>  <td>565.7/22.8</td> <td>80.9</td> </tr>
<tr><td>cat</td>  <td>785</td>  <td>2</td>  <td>2</td> <td>2</td>  <td>4002</td>  <td>123</td>  <td>57.99</td>  <td>262</td>  <td>567.6/19.9</td> <td>79.8</td></tr>
<tr><td>head</td> <td>1063</td> <td>4</td> <td>4</td> <td>4</td>  <td>5007</td>  <td>909</td>  <td>50.97</td>  <td>2002</td>  <td>540.9/20.5</td> <td>80.9</td></tr>
<tr><td>tr</td> <td>1949</td> <td>6</td> <td>6</td>  <td>5</td> <td>37281</td>  <td>1593</td>  <td>64.4</td>  <td>3430</td>  <td>565.5/21.2</td> <td>80.7</td></tr>
<tr><td>expand</td> <td>433</td>  <td>2</td>  <td>1</td> <td>2</td>  <td>3854</td>  <td>2578</td>  <td>55.95</td>  <td>5965</td>  <td>544.4/25.9</td> <td>83.5</td></tr>
<tr><td>unexpand</td> <td>535</td>  <td>2</td>  <td>1</td> <td>2</td>  <td>3996</td>  <td>1560</td>  <td>56.09</td>  <td>3435</td>  <td>544.8/27.2</td> <td>83.1</td></tr>
</table>
<p>#L: Lines of code; </br>#LP: Number of leak points ; </br>#LP<sub>0</sub> #LP<sub>1</sub>: Number of leak points found by our method and Valgrind; </br>#S: Numbers of test cases generated by the path-guided concolic testing;</br>#TC:Number of test cases used by Valgrind;</br>T<sub>0</sub> T<sub>1</sub>:Running times;</br>Sp<sub>0</sub> Sp<sub>1</sub>:Memory consumptions;</br>PS: Overhead of our method includes the static analysis stage, memory consumption data like 549.9/20.4Mb means that static analysis uses 549.9Mb memory and concolic testing uses 20.4Mb memory.</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>If you have any questions or suggestions, please contact us.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/ssthappy">ssthappy</a></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
